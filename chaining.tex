\chapter{Chaining Garbled Circuits}

At the end of the previous chapter, we discussed OT-preprocessing in which some work is in done in an offline phase that speeds up the computation of the online phase.
We can also split the garbled circuits scheme into online/offline phase.
During the offline phase, the garbler generates and garbles the circuit, and sends it to the evaluator.
Then, when the garbler and evaluator acquire their inputs to the function that they want to compute, they exchange input labels - some via the online phase of OT-preprocessing - and the evaluator evaluates the garbled circuit.
Splitting the work into offline/online phases dramatically reduces the real world overhead required in performing secure computation.
Imagine that two banks integrate secure computation into their daily transactions.
At night when activity is low, their servers exchange many garbled circuits, and then during the day, they use the pre-exchanged garbled circuits to quickly do secure comptuation.
The computational requirements for the banks, when they compute the function, is only to exchange input labels and for the evaluator-bank to evaluate the garbled circuit.
The size of the garbled tables and the size of the function are both irrelevant to the computation.

With this more real world scenario, we have a new open question: how can we improve garbled circuits in the offline/online setting?
Let us narrow the question a bit more.
What are the problems with the garbled circuits in the offline/online setting?
Two problems immediately come to mind. 
First, the function that the parties want to perform is fixed by the computation done in the offline phase.
If the two banks want to compute a particular function, but that function was not turned into a circuit and exchanged the night before, then the banks are out of luck - they cannot perform that function in the online/offline model.
We refer to this problem as the flexibilty of functionality problem.
Second, we have the flexibility of inputs problem.
Garbled circuits have a fixed input size.
For some functions, this is not a problem as the extra inputs can simply be padded into $0$s, which solves the problem of flexibilty but causes the evaluator to compute a needlessly large circuit.
Imagine a setting of multiparty computation where multiple parties are voting.
In the online/offline setting, the size of the circuit is fixed, so there is some maximum number of parties that can participate in the election.
If more parties want to vote than predicted, then a party has to create a new function, perform with all parties again, and so on.
It would be great if there some garbled circuit method that could handle arbitarily large or small number of inputs.

This chapter discusses \textit{chaining} garbled circuits, a method which provides flexibility of functionality and flexibility of inputs.
The idea is based on stringing together many smaller garbled circuits in order to compute a larger function.
For example, many useful functions can be decomposed into multiplying matrices.
The garbler can generate a bunch of circuits that multiple matrices and exchange them during the offline phase.
At the beginning of the online phase, the garbler and evaluator agree on a function to compute, figure out how chain their matrix-multiplying-garbled-circuits in a way to compute their function, and do so.
They have know computed a function, which was totally determined at online time.
We might say that garbled circuits exchanged during the offline phase offer a \textit{class} of functions that the evaluator and garbler can compute.
The evaluator and garbler then pick a function from the class of functions during the online phase.

\section{The Random Oracle Model and Random Permutation Model}
\al{Why are we introducing the ROM and RPM?}
In order to discuss chaining, we need to introduce a little more theory.
This section discusses two models in which we imagine cryptographic schemes.

The scheme that we have been working in is called the \textit{standard model} \al{What's it called?}
In the standard model, we assume that parties have access to a polynomial length string of random bits, preset at the beginning of their algorithm.
This string can be used however the parties wish, but it is a static access of randomness.

The \textit{random oracle model} is a relaxation of the standard model.
In the random oracle model, parties have a access to $H$, an oracle that on input of any value, outputs a perfectly random string. 

What is an oracle?

The \textit{random permutation model} is a further relexation of the random oracle model.
In the random oracle model, parties

\section{Chaining}
In this section we describe how to chain together garbled circuits.

Suppose that during an offline phase, Alice garbles many circuits and sends them Bob.
During the online phase, Alice sends Bob input labels, some via oblivious transfer, and then Alice sends Bob \textit{link} labels.
A link label converts an output wire from one garbled circuit to an input wire of another garbled circuit.
Say that Alice and Bob want to set output wire $A$ of a garbled circuit to the input wire $X$ of another garbled circuit.
We suppose that Alice and Bob are using Free XOR, where each garbled circuit uses the same global $\Delta$.

Alice sends Bob $L_{AX} = A \oplus X$.
Bob, who has $A \oplus a\Delta$, sets the $X$ wire label to $A \oplus a\Delta \oplus L_{AX}$.
The $X$ wire label will have value $X \oplus a\Delta$, the same semantic value as wire $A$.

This method requires a single ciphertext be communicated per wire-pair link.

\section{Security of Chaining}
In this section we explain why chaining is secure.
Informally, chaining is secure since the chaining values do not represent any semantic information, and the evaluator cannot infer any further information from them.
The evaluator cannot XOR a chaining value with any other value and gain meaningful information.
Say the evaluator has chaining value $W_{ij}$, chaining $W_i$ to $W_j$. 
The evaluator learns nothing by xoring $W_{ij}$ with $W_i$ or $W_j$, and $W_{ij}$ is not associated with $W_k$ for all $k \neq i,j$, so the evaluator stands to learn nothing.

To think about the security of chaining formally, we modify the experiement of classical garbled circuits to include the chaining step\footnote{The experiment for classical garbled circuits is given in Chapter 2}.
We modify the experiment to the following:


\section{Single Communication Multiple Connections}
\textit{Single Communication Multiple Connections} (SCMC) is a method of reducing the number of linking values that Alice and Bob exchange.
In the naive chaining scheme, online bandwidth sclaes linearly with the number of wires being chained, since a ciphertext is communicated per wire being chained.
For some cases, this is a lot of communication.
If Alice and Bob are chaining two garbled circuits that perform matrix multiplication on $100$ by $100$ matrices with entries that are 16 bits, then Alice sends $8,000$ ciphertexts to Bob - $8,000$ ciphertexts is 4 kBs.
SCMC reduces the chaining operation to require a single ciphertext of communication: an $8,000$x improvement.

SCMC works like most garbled circuits improvements: cleverly choosing wire labels.
The key observation is that consecutive output wires are often chained to consecutive input wires.
Suppose we are chaining garbled circuit $\C_0$ with output wires $\{W_i\}_{i \in \SFOutputs(\C_0})$ to garbled circuit $\C_1$ with input wires $\{Y_i\}_{i \in \SFOutputs(\C_1)}$.
Moreover, for all wires $W_i$ being chained in $\C_0$, $W_i$ is being chained to $Y_j$ where $i = j$; intuitively, a wire in $\C_0$ is being chained to its corresponding wire in $\C_1$.
\al{What does this mean? What is a corrresponding wire?}
Alice, when garbling, sets all output wires $W_i$ to $W_0 \oplus H(T \oplus (i || b))$, and all output wires $Y_i$ to $Y_0 \oplus H(T \oplus (i || b))$ where $H$ is a hash function.

\section{Security of SCMC}
SCMC is known to be secure in the random oracle model.
In the random oracle model, we assume that $H$ is a random function.
That is, on any input $x \in \{0,1\}^*$, $H$ outputs a uniform random bit-string of length $\lambda$.

...


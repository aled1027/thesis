%!TEX root = thesis.tex

\chapter{Chaining Garbled Circuits}

In this chapter we introduce component-based garbled circuits, a method that allows for most of the work involved in building and communicating a garbled circuit to occur in an offline phase before the inputs or function to compute are known. 
This offers significant improvements to the online performance of garbled circuits. 

We begin with the observation that most functions are composed of many smaller components. 
For example, many statistical operations are a composition of matrix operations; smith-waterman and levenshtein distance, two algorithms important to analyzing genomes, are dynamic algorithm that run a single procedure inside a for loop; and encrypting arbitrary length messages via modes of operation repeats the encryption algorithm a number of times.

The gist of component-based garbled circuits is then to build and communicate many garbled components in the offline stage.
Later, in the online stage, the garbler and evaluator choose their inputs, choose a function a compute, and compute the function using the pre-communicated garbled components.
In the online phase, the garbler only communicates input labels and auxiliary information to the evaluator, who stitches together the garbled components into the larger function.

Imagine that two banks integrate secure computation into their daily transactions.
At night when activity is low, the banks' servers exchange many garbled circuits, and then during the day, they use the pre-exchanged garbled circuits to quickly perform secure computation.
The computational requirements for the banks, when they compute the function, is only to exchange input labels and for the evaluator-bank to evaluate the garbled circuit, while, importantly, the banks preserve the ability to choose their inputs and the function to be computed at the time of the computation. 

\section{Chaining}

In this section we describe how to chain together garbled circuits.
Chaining, or stitching together two garbled circuits, essentially takes the output wires of one garbled circuits and converts them into valid input wires of another garbled circuit while retaining the semantic value of the input wires.
For example, say a garbled circuit has two output wires that are chained to a garbled circuit with two input wires.
Unbeknownst to the garbler or evaluator, the output wires both semantically represent 0, so the evaluator must acquire the input labels semantically representing zero.
One naive method of chaining is to send a garbled table, where the table encrypts the input labels using the output labels.
However, a better method exists.

Suppose that Alice and Bob are chaining two garbled circuits.
During an offline phase, Alice garbles many circuits and sends them Bob.
Later, during the online phase, Alice sends Bob input labels, some via oblivious transfer, and then Alice sends Bob \textit{link} labels.
A link label converts an output wire from one garbled circuit to an input wire of another garbled circuit.
Say that Alice and Bob want to set output wire $W_i$ of a garbled circuit to the input wire $W_j$ of another garbled circuit.
We suppose that Alice and Bob are using Free XOR, where each garbled circuit uses the same global $\Delta$.

We formally describe component-based garbled circuits as a tuple of three algorithms $(\Garble, \Link, \Eval)$.
The $\Garble$ algorithm is the same algorithm that we used before to garble circuits; it takes as inputs a circuit $\C$ and outputs three pieces of information: a garbled circuit $\GC$, a set of input wires $e_{\C}$, and a set of output wires $d_{\C}$.
We extend the $\Garble$ algorithm to also take a component-circuit $c$ as input, instead of a complete circuit $\C$, which outputs a garbled component $\GC_c$, input wire set $e_c$ and output wire set $d_c$. 

The $\Link$ algorithm is unique to component-based garbled circuits, and it produces the information neccessary for linking.
$\Link$ takes as input two garbled components $c_0 = (\GC_0, e_0, d_0)$ and $c_1 = (\GC_1, e_1, d_1)$, and a mapping of output wires of $c_0$ to input wires of $c_1$. 
$\Link$ outputs the \textit{link} labels needed to convert the output wires $d_0$ to input wires $e_1$. 
Suppose that output wire $W_i \in d_0$ has labels $(W_i^0, W_i^1)$, and input wire $W_j \in e_1$ has wire labels $(W_j^0, W_j^1)$.
To link $W_i$ to $W_j$, $\Link$ outputs $W_{ij} = W_i^0 \oplus W_j^1$. 
Since Free-XOR is being used, we have that $W_i^0 \oplus W_i^1 = W_j^0 \oplus W_j^1 = \Delta$ for some random value $\Delta$.
$W_{ij}$ is sufficient to transform a wire label of $W_i$ to a wire label of $W_j$ while preserving the semantic value. 
The semantic value is preservered because the $\Delta$ is present in $W_j^*$ if and only if $\Delta$ is present in $W_i^*$; xoring by $\Delta$ simply transform $W_i^0$ to $W_j^0$ and leaves the $\Delta$ alone.

The $\Eval$ algorithm evaluates the garbled components and links garbled circuits where necessary.
It takes three inputs: a list of a garbled components $\{c_i\}$, linking labels $\{W_{ij}\}$ and input labels $\{W_i\}$, and it outputs output labels $\{Z_i\}$. 
$\Eval$ starts with the inputs, and then proceeds component by component, evaluating each component in order to get the component output wire label.
Where necessary, $\Eval$ uses component output wire labels and link labels to compute the appropriate input label for later components. 
Once all components are evaluated, $\Eval$ recovers the garbled outputs $\{Z_i\}$ from the output components, and uses $d$ for that component to recover the real output $y$. 

Let us think about how the two banks who use secure computation in their daily operations employ the three algorithms.
At night, during the offline stage, the garbler-bank generates many circuit components, garbles them with $\Garble$, and sends the garbled circuits to the other evaluator-bank. 
The garbler-bank and evaluator-bank also perform the offline phase of OT-preprocessing.
During the day, when the banks decide that they need to compute some function $f$, they check that they have sufficient components to compute $f$. 
If they do, the garbler-bank runs $\Link$ on the components used in $f$, and sends the output link-labels to the evaluator. 
The garbler and evaluator also exchange wire labels, some via online OT-preprocessing. 
Now that the garbler has the garbled components, link labels and input labels, they run $\Eval$, recovering the output of the function.

\section{Security of Chaining}

In this section, we show how to adapt the standard definition of privacy, presented in chapter 2, to component-based garbled circuits.
Recall from Chapter 2 that we said a garbled circuit scheme is secure if for all probabilistic, polynomial-time simulators (i.e algorithms) $S_1$ and $S_2$ the following holds:
\begin{equation}
    \{(S_1(x, f_1(x,y), f(x,y)))\}_{x,y} \compindist \{(\viewrv^{\Pi}_1(x,y), \outputrv^{\Pi}(x,y)) \}_{x,y}
\end{equation}
\begin{equation}
    \{(S_2(x, f_2(x,y), f(x,y)))\}_{x,y} \compindist \{(\viewrv^{\Pi}_2(x,y), \outputrv^{\Pi}(x,y)) \}_{x,y}
\end{equation}

To consider the security of component-based garbled circuits, we add in the extra information that each party receives into $\viewrv^{\Pi}(x,y)$. 
First, consider the party 1, the garbler. 
The garbler only receives additional information from OT-preprocessing, which we know to be secure. 
So the garbler-side is secure in component-based garbled circuits.

Second, consider party 2, the evaluator. 
The evaluator receives the following information: pre-garbled components $\{GC_i\}$, input labels $\{W_j^{x_j}\}_{j \in \Inputs(C)}$, output map $d_{C_out}$ and link labels $\{W_{ij}\}_{i,j \in \Components}$.
The pre-garbled components, output map and input labels do not reveal any information for the same reasons that they are fine in the standard definition of security.
The wire labels are the xor of two random values, hence they themselves do not reveal any semantic information about the value of a wire. 
Moreover, the link labels cannot be used in conjunction with any wire labels to gain any further information.

It should be noted that this not even close to a formal proof of security.
A formal proof is long, and beyond the scope of this project; rather, this section highlights the intuition behind why we believe a formal proof of security to be possible. 

\section{Single Communication Multiple Connections}

We now introduce \textit{Single Communication Multiple Connections} (SCMC), a technique which improves upon naive component-based garbled circuits for some functions. 
SCMC makes the observation that often large sequences of consecutive wires represent a single element of data, like a string, number or matrix. 
When large sequences of consecutive wires are mapped between garbled components, the sequence of consecutive wires is mapped together - the order of the wires is preserved. 
SCMC takes advantage of this fact by requiring that only a single link label is communicated for each sequence of consecutive wires, as opposed to one link label per wire. 

\al{CompGC paper notes that we could use permutation garbled components to deal with this problem, making things more efficient sometimes}

As with most improvements to garbled circuits, SCMC operates by modifying the generation of wire labels. 
Wire labels that are part of a block representing a single piece of data are generated in a fixed, patterned way such that the differences between linked labels will be the same for all wires in a block. 

SCMC modifies the $\Garble$ algorithm by choosing input wires and output wires in a particular way. 
For every component, we first choose three random labels $A,B$ and $T$: $A$ and $B$ are the base values for input wires and output wires respectively, and $T$ is a tweak value, ensuring security for the hash function.
We next assume that all parties have access to a random oracle $H$. 
A random oracle is a theoretically perfect random function, which on input of any value $x \in \{0,1\}^*$, returns a value from $\{0,1\}^{\lambda}$ selected uniformly at random.
In practice, we use a hash function for $H$. 
Then, for all input wire labels $W_i^b$, set wire label $W_i^b$ to $A \oplus H(T \oplus (i || b))$. 
Likewise, for all output wires labels $W_i^b$, we do the same process, setting $W_i^b$ to $B \oplus H(T \oplus (i || b))$.

Suppose that all output wires of component $c_0$ are being linked to the input wires component $c_1$, where the $i$th input wire is being mapped to the $i$th output wire. 
Then, it is sufficient for the garbler to send $B_{c_0} \oplus A_{c_1}$ to the garbler. 
This works since for any wire $i$ and bit $b$,
\begin{equation}
(B_{c_0} \oplus H(T \oplus (i || b)) \oplus (B_{c_0} \oplus A_{c_1}) = A_{c_1} \oplus H(T \oplus (i || b))
\end{equation}

Evaluation is the same as naive component-based garbled circuits, wherein the evaluator links using the correct wire label.

\subsection{Analysis}
SCMC substantially reduces the amount of communication required for chaining. 
For example, if AES is being computed where the components are single AES rounds, then SCMC requires only $9$ link labels to be communicated between the garbler and evaluator; naive component-based garbled circuits requires $1152$ labels. 

The milage of SCMC varies based on the function being computed and components being used. 
SCMC offers the most benefits to functions that are modular, and where large amounts of data are being passed around, like matrix-based functions and dynamic algorithms like Levenshtein distance. 
SCMC is less effective when data moves in a more unpredictable manner, like in the computation of 
Finally, SCMC does not scale with an increase in data size. 
SCMC requires that a single link label being communicated for a 2 by 2 matrix and for a 1,000 by 1,000 matrix. 
Thereby, SCMC offers a great benefit to the secure computation of large statistical computations, such as those that might be performed by hospitals or on genomes. 

\section{Security of SCMC}
The security of SCMC follows directly from the security of naive component-based garbled circuits. 
First, SCMC alters the generation of some wire labels.
The new method of generating wire labels is secure since $H$ is random function, hence $H(\cdot)$ blinds $A$ and $B$.
In particular, the wire labels are only distinguishable if the evaluator can determine $T$, which is not possible since $H$ is a random function.
Therefore, SCMC is intuitively secure. 

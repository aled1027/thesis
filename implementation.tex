%!TEX root = thesis.tex

\chapter{Implementation}

I implemented the theoretical ideas of component-based garbled circuits and SCMC in a program called \CompGC. 
This chapter describes the creation of \CompGC, and at the end presents experimental results. 

The aim of \CompGC is to run a two party garbled circuit protocol from start to finish. 
\CompGC has a garbler-side and an evaluator-side, which is specified with command line arguments.
It operates in two phases.
In the first phase, the offline phase, the garbler sends garbled circuits to the evaluator, and they perform the offline phase of OT-preprocessing.
In the second phase, the online phase, the garbler sends input labels for the garbled circuits, some of which are exchanged via the online phase of OT-preprocessing, instructions for how the evaluator should chain the garbled circuits, and output garbled circuits which are garbled circuits composed of a single, unary gate that encode the real output of the function being processed.
The following section goes into more detail into the particular of the \CompGC protocol.

\section{\CompGC}
I initially constructed \CompGC on top of \JustGarble.
\JustGarble is a system for garbling and evaluating circuits, and it only garble circuits and evaluates.
\JustGarble takes as input a circuit and can output a garbled circuit, and similarly, it can take as input a garbled circuit and input wires and return the output of the garbled circuit.
While building \CompGC, \LibGarble was being developed by a researcher at University of Maryland.
\LibGarble is a fork of \JustGarble - that is, the researcher took the code of \JustGarble as his starting point -  and offers the same functionality as \JustGarble, but it has a better API, is faster, and supports more features, namely half-gates.
I eventually started using \LibGarble in \CompGC.

Starting with \JustGarble and \LibGarble, which perform a very specific task, meant that I needed to add many steps and features to make a fully functional garbled circuit system.
I started by adding oblivious Transfer, for which I found an implementation of the Naor-Pinkas algorithm.
Naor-Pinkas is basic, semi-honest oblivious transfer.
A colleague of mine later added to the oblivious transfer code to support OT-preprocessing.


I will now walk through the 4 basic modes of \CompGC: garbler-offline, evaluator-offline, garbler-online and evaluator-online.
Algorithm \ref{alg:garbler-offline} outlines the garbler's offline implementation.

\begin{algorithm}
    \caption{Garbler Offline}
    \label{alg:garbler-offline}
    \begin{algorithmic}
        \State \textbf{Input:} List of circuits, and number of ciphertexts to be OT-preprocessed.
        \State 1. Build circuits
        \State 2. Garble circuits (using \LibGarble)
        \State 3. Assign each garbled circuit an ID
        \State 4. Send garbled circuits and their IDs to evaluator
        \State 5. Save input labels and output labels of garbled circuit to disk
        \State 6. Perform offline phase of OT-preprocessing
        \State 7. Save data from OT-preprocessing to disk
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption{Evaluator Offline}
    \label{alg:evaluator-offline}
    \begin{algorithmic}
        \State 1. Receive garbled circuits from garbler
        \State 2. Save garbled circuits to disk
        \State 3. Perform offline phase of OT-preprocessing
        \State 4. Save OT-preprocessing data to disk
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption{Garbler Online}
    \label{alg:evaluator-offline}
    \begin{algorithmic}
        \State 1. Load input labels and output labels of garbled circuits from disk
        \State 2. Load OT-preprocessing data from disk
        \State 3. Load function specification from disk
        \State 4. Generate instructions from function specification
        \State 5. Compute chaining values, and add values to instructions
        \State 7. Perform online stage of OT-preprocessing
        \State 8. Send input wires correspond to garbler's input
        \State 9. Send instructions
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption{Evaluator Online}
    \label{alg:evaluator-offline}
    \begin{algorithmic}
        \State 1. Load garbled circuits from disk
        \State 2. Load OT-preprocessing data from disk
        \State 3. Perform online stage of oblivious transfer - acquire evaluator's input labels
        \State 4. Receive garbler's input labels
        \State 5. Receive instructions
        \State 6. Following instructions, chaining and evaluating as instructed
    \end{algorithmic}
\end{algorithm}

\section{Experiments}
\CompGC experiments were run on an Intel Core i5-4210H CPU. 
They were conducted over two network settings. 
The first network setting ran both parties on the default localhost configuration, which was measured to have a latency of 0.012 ms and bandwidth of 25.2 Gb per second. 
The second network setting used the built in Linux network emulator {\sf netted} to configure localhost to mimic the latency and bandwidth of the internet. 
This included setting latency to 33 ms and bandwidth to 50 Mbits per second. 
Finally, \CompGC requires reading from disk; our experimental machine was measured to have cache reads speed of 6.7 GB per second and buffered disk reads speed of 96 MB per second.

We ran four experiments: AES, CBC mode, and Levenshtein distance with 30 symbols and with 60 symbols. 

In the AES experiment, we treated each round of AES as a separate component. AES has 10 rounds, and hence required linking 10 components. Moreover, we used 128-bit AES, meaning that each component link required linking 128 wires. 

CBC mode is an algorithm for encrypting messages of arbitrary length using a blockcipher, for which we used AES-128. 
We again used a single round of AES as a component, and we also used XOR component, which took 256 bits of input, and outputted their xor. 
For our experiment, we ran CBC mode on a 10 block message, a 1,280 bit string, thus requiring 110 components - 100 for AES rounds and 10 for XOR. 

Levenshtein distance is a dynamic algorithm that computes the distance between strings. 
We use the Levensthein core circuit, as described by Huang et al. \cite{asdf}, as the only component. 
See figure \ref{ads} for an outline of the core circuit. \al{add circuit}
For our experiments, we used an 8-bit alphabet and ran Levenshtein distance on strings of length 30 symbols and on strings of length 60 symbols, corresponding to 900 and 3600 components respectively. 

\section{Results}
\al{Get table!}
Table \ref{asdf} shows the results of the experiments explained above. 
The columns denoted \Naive show times of our system using the standard component-based garbled circuits; and the column denoted SCMC uses SCMC to reduce communication. 


























































%!TEX root = thesis.tex

\chapter{Implementation}

I implemented the theoretical ideas of component-based garbled circuits and SCMC in a program called \CompGC. 
This chapter describes the creation of \CompGC, and at the end presents experimental results. 

The aim of \CompGC is to run a two party garbled circuit protocol from start to finish. 
\CompGC has a garbler-side and an evaluator-side, which is specified with command line arguments.
It operates in two phases.
In the first phase, the offline phase, the garbler sends garbled circuits to the evaluator, and they perform the offline phase of OT-preprocessing.
In the second phase, the online phase, the garbler sends input labels for the garbled circuits, some of which are exchanged via the online phase of OT-preprocessing, instructions for how the evaluator should chain the garbled circuits, and output garbled circuits which are garbled circuits composed of a single, unary gate that encode the real output of the function being processed.
The following section goes into more detail into the particular of the \CompGC protocol.

\section{\CompGC}
\CompGC is my implementation of component-based garbled circuits. 
I originally started with \JustGarble as my basic building block. 
\JustGarble is a C-library written by Bellare et al \cite{justgarble}. 
It creates a garbled circuit given an inputted circuit, and evaluates the garbled circuit given input labels. 
It is only a tool, supporting garbling and evaluating operations, but does not perform the many operations needed for a whole secure system, like networking, oblivious transfer, and secure recovery of final outputs. 

I eventually replaced \JustGarble with \LibGarble in my implementation.
\LibGarble was created by a colleague of mine, Alex Malozemoff, and is an improvement on \JustGarble.
\LibGarble cleaned up the API, improved the memory layout of the garbled circuit data-structure and made other modifications. 
These improvements contributed to a substantial increase in performance: 17 cycles per gate required for evaluating an AES circuit as opposed to 22 cycles per gate in \JustGarble, a 22\% improvement. 
\LibGarble also adds the newest cryptographic technique, half-gates, but \CompGC does not use half-gates since half-gates reduces the size of the garbled table at the cost of a single call to the hash function during evaluation. 
In the component-based garbled circuit setting, the garbled tables are communicated during offline time, and we are most concerned with online time when the hash function would be called. 

\CompGC has an offline and an online phase. 
In the offline phase, \CompGC takes as input a list of circuits and computes a specified number of each circuit. 
The list of circuits could be small and focused, designed for computing a single function such as AES, or the list could be diverse, allowing for the computation of a variety of functions. 
\CompGC garbles the list of circuits the specified number of times, sends the garbled circuits with an attached identification number from the garbler to the evaluator. 
The garbler and evaluator each save the garbled circuits to disk. 
Finally, the garbler and evaluator perform the offline phase of preprocessed oblivious transfer. 
\CompGC uses the Naor-Pinkas semi-honest oblivious transfer protocol; the library for performing oblivious transfer was given to me by Alex Malozemoff. 
The garbler finishes by saving the input labels and oblivious transfer data to disk, and similarly, the garbler saves the oblivious transfer data to disk. 
Algorithms \ref{alg:garbler-offline} and \ref{alg:evaluator-offline} show the steps taken by each party in the offline phase. 

In the online phase, the evaluator begins by loading up the function to be computed from disk. 
We specify the function in a JSON format, in which the following information is laid out: components needed in the function, how components input and output wires are linked, where inputs should go, and what wires are outputs. 
We chose to use JSON because the file format is human readable, but a different format, like something in binary, would be faster. 
As the functions become more complex, it becomes harder to write the function specification files. 
To overcome this, I wrote a python script that automatically generates the function specification file for various functions on arbitrary inputs. 

After the garbler loads the functions specification file from disk, it generates a set of instructions for the evaluator. 
The instructions specify what components are used by naming with the unique ID assigned in the offline phase. 
The instructions further specify in what order to evaluate components, and in what order and how to link components. 
This step requires specifying the output wires of one garbled circuit, the input wires of another garbled circuit, and the linking value.
Finally, the instructions specify how to map the final output wire labels to bits; this essentially works by sending two-row garbled gates for each output wire. 

After the garbler sends the instructions to the evaluator, they perform the online phase of oblivious transfer, whereby the evaluator acquires their input labels. 
The garbler next sends the input labels corresponding to their inputs. 
At this point, the evaluator has all the data they need to finish the protocol. 
They follow the instructions, and acquire the output bits. 

Algorithms \ref{alg:garbler-online} and \ref{alg:evaluator-online} summarize the online phase. 

\begin{algorithm}
    \caption{Garbler Offline}
    \label{alg:garbler-offline}
    \begin{algorithmic}
        \State \textbf{Input:} List of circuits, and number of ciphertexts to be OT-preprocessed.
        \State 1. Build circuits
        \State 2. Garble circuits (using \LibGarble)
        \State 3. Assign each garbled circuit an ID
        \State 4. Send garbled circuits and their IDs to evaluator
        \State 5. Save input labels and output labels of garbled circuit to disk
        \State 6. Perform offline phase of OT-preprocessing
        \State 7. Save data from OT-preprocessing to disk
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption{Evaluator Offline}
    \label{alg:evaluator-offline}
    \begin{algorithmic}
        \State 1. Receive garbled circuits from garbler
        \State 2. Save garbled circuits to disk
        \State 3. Perform offline phase of OT-preprocessing
        \State 4. Save OT-preprocessing data to disk
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption{Garbler Online}
    \label{alg:garbler-online}
    \begin{algorithmic}
        \State 1. Load input labels and output labels of garbled circuits from disk
        \State 2. Load OT-preprocessing data from disk
        \State 3. Load function specification from disk
        \State 4. Generate instructions from function specification
        \State 5. Compute chaining values, and add values to instructions
        \State 7. Perform online stage of OT-preprocessing
        \State 8. Send input wires correspond to garbler's input
        \State 9. Send instructions
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption{Evaluator Online}
    \label{alg:evaluator-online}
    \begin{algorithmic}
        \State 1. Load garbled circuits from disk
        \State 2. Load OT-preprocessing data from disk
        \State 3. Perform online stage of oblivious transfer - acquire evaluator's input labels
        \State 4. Receive garbler's input labels
        \State 5. Receive instructions
        \State 6. Following instructions, chaining and evaluating as instructed
    \end{algorithmic}
\end{algorithm}

\section{Experiments}
\CompGC experiments were run on an Intel Core i5-4210H CPU. 
They were conducted over two network settings. 
The first network setting ran both parties on the default localhost configuration, which was measured to have a latency of 0.012 ms and bandwidth of 25.2 Gb per second. 
The second network setting used the built in Linux network emulator {\sf netted} to configure localhost to mimic the latency and bandwidth of the internet. 
This included setting latency to 33 ms and bandwidth to 50 Mbits per second. 
Finally, \CompGC requires reading from disk; our experimental machine was measured to have cache reads speed of 6.7 GB per second and buffered disk reads speed of 96 MB per second.

We ran four experiments: AES, CBC mode, and Levenshtein distance with 30 symbols and with 60 symbols. 

In the AES experiment, we treated each round of AES as a separate component. AES has 10 rounds, and hence required linking 10 components. Moreover, we used 128-bit AES, meaning that each component link required linking 128 wires. 

CBC mode is an algorithm for encrypting messages of arbitrary length using a blockcipher, for which we used AES-128. 
We again used a single round of AES as a component, and we also used XOR component, which took 256 bits of input, and outputted their xor. 
For our experiment, we ran CBC mode on a 10 block message, a 1,280 bit string, thus requiring 110 components - 100 for AES rounds and 10 for XOR. 

Levenshtein distance is a dynamic algorithm that computes the distance between strings. 
We use the Levensthein core circuit, as described by Huang et al. \cite{asdf}, as the only component. 
See figure \ref{ads} for an outline of the core circuit. \al{add circuit}
For our experiments, we used an 8-bit alphabet and ran Levenshtein distance on strings of length 30 symbols and on strings of length 60 symbols, corresponding to 900 and 3600 components respectively. 

\section{Results}
\al{Get table!}
Table \ref{asdf} shows the results of the experiments explained above. 
The columns denoted \Naive show times of our system using the standard component-based garbled circuits; and the column denoted SCMC uses SCMC to reduce communication. 

\input{table-results-no-load}



























































\chapter{Improving MPC}
A number of improvements have been made to garbled circuits over the last two decades.
The aim of this chapter is to outline the major improvements made to garbled circuits and discuss the costs and benfits of the improvments.

We consider 3 metrics that describe the costs of garbled circuits.
First, we consider bandwidth per gate.
In the classic scheme of garbled circuits, described in chapter 2, the garbler and evaluator communicated 2 pieces of information: wire labels for input wires and the fourth column of the garbled table for each gate \footnote{In chapter 2, Alice was the garbler and Bob was the evaluator. For clarify in chapter 3 and beyond, we use the term garbler to allude to the person who garbles the circuit, and we use the term evaluator to describe the person who evaluates, or decrypts, the garbled circuit.}.
Sending the input lables is an unavoid able costs, with the major caveat that using oblivious transfer to communicate the evaluator's input labels has substantial costs.
Oblivious transfer has been improved to require a small, constant amount of communication and minimal computation requirements for garbler and evaluator, if they can perform some computation \textit{before} executing the protocol.
Improvements to oblivious transfer are discussed in more detail below.

The garbler and evaluator also commnicate the garbled table\footnote{In this chapter, the garbled table will be used interchangeably with the fourth column of the garbled table.}.
Classical garbled circuits require that all four rows of the garbled table be communicated, that is 4 ciphertexts.
Recent research has reduce the number of ciphertexts to approximately $0.5$ depending on the circuit being computed.
We generally consider bandwidth to be the most important factor, as the high latency of the internet is generally the bottleneck of executing garbled circuits.

Second, we consider evaluator-side computation, which is determine by the number decryptions the evaluator performs per gate.
Third, consider garbler-side computation.
Many improvements to MPC increase the amount of garbler-side computation; having the garbler do more work can reduce the size of the garbled table which reduces bandwidth.

As we walk through the improvements to Yao's garbled circuit, we are going to think about the improvements affect the three metrics described above.
It should also be noted before we begin that these are improvements to the the computation of a single gate.
Speedups to the computation of a gate propagate through the computation of the entire garbled circuit.
For example, the computation of AES now requires approximatley $40,000$ gates, so reducing the number of ciphertexts being transmitted by $1$ per gate reduces the total ciphertexts communicated by $10,000$.

Table \ref{tbl:gc-costs} is an overview of the cost of all improvements made to garble circuits.
The table is split into three sections: size, eval cost and garble cost.
Size is the size of the garbled table per gate.
Eval cost is number of encryptions that the evaluator performs per gate, and decryptions is the number of decryptions that the garbler performs per gate.
Each section is divided into two columns: AND and XOR.
The AND columns show the requirements for AND gates, and the XOR columns show the cost for XOR gates.
The columns are separate, because many of the improvements reduce the costs of one type of gate but not the other.

The goal of this chapter is primarily to explain each row in this table.
How the improvement works, and the computational and bandwidth effects of the improvement.
We start with the earliest improvement and move chronological to the most recent improvement.

\begin{table}[t]
    \label{tbl:gc-costs}
    \centering
    \renewcommand{\arraystretch}{1.2}
    \begin{adjustbox}{width=1\textwidth}
        \begin{tabular}{|p{5cm}|c|c|c|c|c|c|c|}
            \hline
            \multirow{2}{5cm}{\centering \textbf{Garbled Circuit Improvement}} & 
            \multicolumn{2}{c|}{\textbf{Size (x$\lambda$)}} & 
            \multicolumn{2}{c|}{\textbf{Eval Cost}} & 
            \multicolumn{2}{c|}{\textbf{Garble Cost}} &
            \multirow{2}{3cm}{\centering \textbf{Assumption}} \\
            \cline{2-7}
            & \textbf{XOR} & \textbf{AND} & \textbf{XOR} & \textbf{AND}  & \textbf{XOR} & \textbf{AND} & \\
            \hline
            Classical & 4 & 4 & 1024 & $\mu$ s & a & b & a\\ \hline
            Point and Permute & TBD & TBD & TBD & $\mu$ s & a & b & a\\ \hline
            GRR3 & TBD & TBD & TBD & $\mu$ s  & a & b& a\\ \hline
            Free XOR & TBD & TBD & TBD & $\mu$ & a & bs& a  \\ \hline
            GRR2 XOR & TBD & TBD & TBD & $\mu$ & a & bs  & a\\ \hline
            FleXOR& TBD & TBD & TBD & $\mu$ & a & bs & a \\ \hline
            Half Gates & 2 & 0 & 2 & 0 & 4 & 0 & a \\ \hline
        \end{tabular}
    \end{adjustbox}
    \caption{Summary of Garbled Circuit Improvements. GRR3 stands for garbled row reduction 3 and GRR2 stands for garbled row reduction 2}
\end{table}

\section{Point and Permute}
\al{add in that rows need to be permuted!}

Beaver, Micali and Rogaway contributed the first major improvement to garbled circuits in 1990.
Recall that the garbled table is randomly permuted - that is, the rows of the garbled table are reordered randoml by the garbler before the table is sent to the evaluator \footnote{This is required for security. See chapter 2 for more information}.
Upon receiving the circuit, the garbler attempts to decrypt each row of the garbled table until a decryption succeeds \footnote{Recall that the decryption algorithm outputs a single bit indicating whether or not the decryption was successful. For more information, see chapter 1.}.

The \textit{point and permute} technique speeds up the evaluator's computation of the garbled table by removing the need to trial decrypt the ciphertexts; instead, the garbler subtly communicates which ciphertext to decrypt.
In point and permute, the garbler randomly assigns a select bit $0$ or $1$ to each wire label of the gate's input wires, where wire lables of the same wire have opposite bits.
That is, if the zeroith wire label has select bit 1, then the first wire label has select bit 0.
The garbler permutes the garbled table based on the select bits, and sends the select bits to the evaluator.
Upon receving the garbled table, the evaluator knows exactly which ciphertext to decrypt based on the select bits of the input wires.

Tables \ref{tbl:point-and-permute} show an example of point and permute.
$A, B$ and $C$ are wires, where $A_0$ and $A_1$ are the zeroith and first wire label of wire $A$ respectively.
The left table shows the select bits of the input wires $A$ and $B$.
The garbler gives $A_0$ select bit 0, determining that $A_1$ has select bit 1.
Likewise, the garbler gives $B_0$ select bit 1, determining that $B_1$ has select bit 0.

The garbler then permutes the garbled table based on the select bits. 
The permuted table is shown on the left in table \ref{tbl:point-and-permute}.
When evaluating this gate, the evaluator has $A_*$ and $B_*$ with select bits $a$ and $b$.
The evaluator decrypts the ciphertext in the row corresponding $a$ and $b$.

Intuitively, point and permute is secure because the select bits are independent of the truth value (also known as semantic value) of a the wire.
This allows the garbler to permute the table based on the select bits, and the garbler can send the evaluator the select bits.

Point and permute slightly increases garbler-side computation to substantially decrease evaluator-side computation.
The garbler samples $4$ additional random bits, and the evaluator performs a single decryption.
Without point and permute, the evaluator needs to decrypt $2.5$ ciphertexts on average, hence the garbler performs roughly $1.5$ fewer decryptions per gate.
The overall bandwidth is increased by $4$ bits per gate: a small constant increase. \footnote{The value is constant in the sense that it is independent of the security parameter.}

\begin{table}
    \label{tbl:point-and-permute}
    \centering
    \begin{tabular}{|c|c|}
        \hline
        Select Bit & Wire Label \\
        \hline
        0 & $A_0$ \\
        1 & $A_1$ \\
        1 & $B_0$ \\
        0 & $B_1$ \\
        \hline
    \end{tabular}
    \qquad
    \begin{tabular}{|c|c|}
        \hline
        Select Bits & Encryption \\
        \hline
        (0,0) & $\Enc_{A_0, B_1}(C_1)$ \\
        (0,1) & $\Enc_{A_0, B_0}(C_0)$ \\
        (1,0) & $\Enc_{A_1, B_1}(C_0)$ \\
        (1,1) & $\Enc_{A_1, B_0}(C_0)$ \\
        \hline
    \end{tabular}
    %\qquad
    %\begin{tabular}{|c|}
    %    \hline
    %    $C_0 \gets \{0,1\}^n$ \\
    %    $C_1 \gets \{0,1\}^n$ \\
    %    \hline
    %\end{tabular}
    \caption{Garbled Gate for Point and Permute}
    %\caption{Example garbled gate using point and permute. The gate being computed is given in figure \textbf{Make it 23:30 in mike's talk}}
\end{table}

\section{Garbled Row Reduction 3}
Garbled Row Reduction 3 (GRR3) reduces the size of the garbled table from 4 ciphertexts to three 3 ciphertexts.
In classical garbled circuits, the wire labels for each wire are chosen prior to garbling any gates.
In GRR3, the input wire labels are sampled in the beginning, and the other wire labels are chosen as each garbled table is created.

Suppose that a gate with input wires $A$ and $B$ and output wire $C$ is being garbled.
In GRR3, the garbler uses the point and permute method.
After the garbler samples select bits and permutes the garbled table, they set the ciphertext in the top row of the garbled table equal to a value that decrypts to $0^n$, the string of $n$ zeros.
That is, $C_*$, the wire label on the top row, is set to $\EncInv_{A_*, B_*}(0^n)$.
The garbler sends the bottom three rows of the garbled table to the evaluator.

When evaluating the garbled gate, if the evaluator sees that the select bits of the input wires indicate to decrypt the first row, the evaluator simply assumes the ciphertext be of value $O^n$. 
Otherwise, the evaluator decrypts the indicated row of the garbled table as per usual.

Tables \ref{tbl:grr3} gives an example of garbling an XOR gate.
The left table shows the select bits of wire labels $A_0, A_1, B_0$ and $B_1$.
The right table shows the garbled table, in which the top row, the row associated with select bits $(0,0)$, is missing.
The bottom table shows the values of $C_0$ and $C_1$.
The value of $C_0$ is randomly sampled from $\{0,1\}^n$.

\begin{table}
    \centering
    \begin{tabular}{|c|c|}
        \hline
        Select Bit & Wire Label \\
        \hline
        0 & $A_0$ \\
        1 & $A_1$ \\
        1 & $B_0$ \\
        0 & $B_1$ \\
        \hline
    \end{tabular}
    \qquad
    \begin{tabular}{|c|c|}
        \hline
        Select Bits & Encryption \\
        \hline
        (0,1) & $\Enc_{A_0, B_0}(C_0)$ \\
        (1,0) & $\Enc_{A_1, B_1}(C_0)$ \\
        (1,1) & $\Enc_{A_1, B_0}(C_0)$ \\
        \hline
    \end{tabular}
    \qquad
    \begin{tabular}{|c|}
        \hline
        $C_0 \gets \{0,1\}^n$ \\
        $C_1 \gets \Enc_{A_0, B_1}^{-1}(0^n)$ \\
        \hline
    \end{tabular}
    \caption{Example garbled gate using point and permute and garbled row reduction 3. The gate being computed is given in figure \textbf{Make it 23:30 in mike's talk}}
    \label{tbl:grr3}
\end{table}

\al{add more to this paragraph}
In considering the security of GRR3, we consider the effect of always setting one the wire labels, $C_*$, to $0^n$.
Since the evaluator does not know whether $C_0$ or $C_1$ is set to $0^n$, the evaluator does not learn any information.

GRR3 offers good performance benefits.
It increases garbler side computation by requiring an additional decryption operation.
However, evaluator perform slightly less computation: in the event that the first row is to be decrypted, the evaluator does not perform the decryption algorithm. 
This events occur with probabilty $\frac{1}{4}$, so we can extrapolate that the evaluator performs $\frac{1}{4}$ fewer decryptions.
Finally, GRR3 reduces the size of the garbled table from $4$ ciphertexts to $3$ ciphertexts, a $25\%$ reduction.

\section{Free XOR}
The Free XOR technique makes the computation of XOR gates free, in the sense that no garbled table need to be communicated.
The evaluator can compute $C_*$ from only $A_*$ and $B_*$.

Like GRR3, the free xor techniques takes advantage of carefully crafted wire labels, even input wires.
To start, the garbler randomly samples a ciphertext $\Delta$ from $\{0,1\}^n$.
For each input wire $A$, let $A_0$ be randomly sampled from $\{0,1\}^n$ as before, and set $A_1 = A_0 \oplus \Delta$.

If the garbler is garbling an XOR gate, then the garbler does not constructed a garbled table or use select bits.
The garlber sets $C_0 = A_0 \oplus B_0$ and sets $C_1 = C_0 \oplus \Delta$.

The evaluator, when evaluating an XOR gate, simply computes $C_* = A_* \oplus B_*$.
As simple as it is, the evaluator will always acquire the correct value for $C_*$ based on the semantic value of $A_*$ and $B_*$.
The math for each of the four cases is shown:
\begin{align*}
    A_0 \oplus B_0 & = C_0 \\
    A_0 \oplus B_1 & = A_0 \oplus (B_0 \oplus \Delta) = (A_0 \oplus B_0) \oplus \Delta = C_1 \\
    A_1 \oplus B_0 & = (A_0 \oplus \Delta) \oplus B_0 = (A_0 \oplus B_0) \oplus \Delta = C_1 \\
    A_1 \oplus B_1 & = (A_0 \oplus \Delta) \oplus (B_0 \oplus \Delta) = (A_0 \oplus B_0) = C_0
\end{align*}
For any wire $A$, since $A_1$ is dependent on $A_0$, we often simplify notation such that the wire labels for $A$ are $A$ and $A \oplus \Delta$, omitting the subscript.

Free XOR is compatible with point and permute and GRR3; however, since XOR does not require a garbled table, GRR3 is only used on AND gates.

\al{discuss security. Why is free xor secure?}
One interesting implication of using the Free XOR technique is that an added assumption must be made to our encryption algorithm.
Since $\Delta$ is part of the key and part of the the payload\footnote{The payload is the value that is being encrypted} of the encryption algorithm, the encryption algorithm must be secure under the circularity assumption.
Fortunately, the popular encryption scheme AES-128 is presumed to be secure under the circularity assumption.

Free XOR dramatically reduces bandwidth.
But since XOR gates are much cheaper than AND gates, circuits with more XOR gates perform faster.
Many programs have been made to optimize the number of XOR gates and minimize the number of AND gates (while minimizing the size of the entire circuit of course).
The garbler-side computation is reduced: constructing the xor garbled table does not require 3 encryptions and 1 decryption.
Evaluator-side computation is reduced likewise: xor gates do not requre any decryption.

\section{Garbled Row Reduction 2}
Garbled row reduction 2 (GRR2) reduces the size of the garbled table of AND gates to $2$ ciphertexts.
Unfortunatley, GRR2 is not compatible with Free XOR, as it require that the zeroith and first wire labels of each wire bear a specific relationship.
Because GRR2 is incompatible with FreeXOR, it is not often used in practice.

\al{I don't think much more needs to be said, but this should be clearer}
GRR2 is much different from GRR3.
When garlbing a gate, GRR2 creates two third degree polynomials.
One polynomial corresponds to $C_0$, and the other polynomial corresponds to $C_1$.
As such, that $C_0$ polynomial is defined by the wire labels that result in $C_0$, and likewise the $C_1$ polynomial is defined by the wire labels that result in $C_1$.
Since each polynomial is of degree three, they are generated by $3$ points.
The garbler sends over 2 points of each polynomial, and the final point is supplied by the input wire labels to the gate.
Upon acquriring three points for one of the polynomials, the evaluator interpolates the polynomial, and plugs in values to recover $C_*$.

%\begin{itemize}
%    \item use unique deg-2 polynomial
%    \item use 2 second degree polynomials
%    \item then interpolate
%    \item can't do free xor.
%    \item because we have lost control of $C_0$ and $C_1$ (they are dependent on the polynomial)
%\end{itemize}

\section{FleXOR}
After the creation of GRR2, secure computation was at an awkward point.
Circuits with many XOR gates were comptuted most quickly with Free XOR, but circuits with many AND gates were computed most quickly with GRR2.
FleXOR reconciles GRR2 with Free XOR, giving researchers a technique that is universally faster.

GRR2 is incompatiable with FreeXOR because the wire labels on output wires of AND gates the result of plugging a value into a polynomial.
The wire labels are solely dependent on the polynomial, so that $C_1 = C_0 \oplus \Delta_C$ for some random $\Delta_C$ not the global $\Delta$ used for FreeXOR.
FleXOR solves this problem in a straightforward fashion: correct the delta value of output wires of AND gates such that the output wires use the global delta.
To correct the value, FleXOR adds a unary gate after each AND gate that corrects the wire label. \footnote{A unary gate is a gate that takes a single input wire and outputs a single wire. The unary gate does not change the semantic meaning of a wire label - that is, whether it represents 0 or 1. The unary gate merely alters the actual value of the wire label or ciphertext.}

Suppose an XOR gate has input wires $A$ and $B$ and output wire $C$.
Input wires $A$ and $B$ each come from an AND gate, so their labels are the result of the polynomial interpolation of GRR2.
$A$ has labels $A$ and $A \oplus \Delta_A$ and $B$ has labels $B$ and $B \oplus \Delta_B$.
To perform Free XOR, $A,B$ and $C$ need to be using the same delta value. 
The garbler adds an extra gate between $A$ and $B$ and the $XOR$ gate that adjusts their XOR value to the correct value.
$A$ and $A \oplus \Delta_A$ change to $A'$ and $A' \oplus \Delta$.
$B$ and $B \oplus \Delta_B$ change to $B'$ and $B' \oplus \Delta$.
Since $A, B$ and $C$ have the same delta value, FreeXOR is used.

The unary gate maps $A,A \oplus \Delta_1 \to A', A' \oplus \Delta$, where $\Delta$ is the correct delta value for the XOR gate.

FreeXOR can be improved by not corrected every output wire of an AND gate.
For example, if an output wire of an AND gate is immiedatley inputted into another AND gate, it does not need to fixed.
Moreover, the wires do not need to be corrected to a global delta.
Free XOR only requires that the three wires involved in the gate, $A, B$ and $C$, use the same delta, so each XOR gate has its own $\Delta$ that is uses. 
For example, $A$ and $C$ may share a delta but $B$ may have a different delta, so it is sufficient to only correct $B$'s delta value.

One issue that FleXOR raises is that circuits can be optimized to perform quickly in it. 
FleXOR is fastest when AND gates are grouped together and XOR gates are grouped together, since fewer unary gates will be required.
This optimization turns out to be NP-hard, but fortunately, FleXOR works well without much (or any) optimization to the circuit.
Reserach reveals that FleXOR requires on average an extra $0$ or $1$ ciphertext per gate.
That cost comes at the benefit of a Free XOR circuit, and 1 fewer ciphertext for each AND gate.

FleXOR requires slightly more garbler-side computation than FreeXOR and GRR2, since the garbler must create the unary gates.
The size of the XOR garbled table is $0$, and the size of the AND garbled table is $2$, with the addition of the garbed table of the unary gate.
The garbled table of the unary gate has $2$ ciphertexts, and the number of unary gates depends on the circuit.
The evaluator-side computation is the same as FreeXOR and GRR2, with the additional computation of the unary gates, which is small.

FleXOR is intuitively secure, since the only additional information beyond GRR2 and FreeXOR is the unary gates.
The unary gate is secure, since it functions the same as a normal garbled gate except that an input is missing.
However, FreeXOR requires the circularity assumption, 
The circularity assumption is discussed in the section on FreeXOR.

%\begin{itemize}
%    \item switch delta value: $A,A \oplus \Delta_1 \to A', A' \oplus \Delta_2$
%    \item cost a single ciphertext (after using GRR3 trick)
%    \item total cost 0,1,2 dependent on how many distinct deltas
%    \item make wire label outputs of AND gates based on polynomial interpolation (GRR2)
%    \item So we can do both free xor (which cost 0 CTs) and GRR2 (which cost 2 CTs per And gate + delta correction)
%    \item turns into combinatorial optimization problem: determine offset for each wire to minimize total cost of each xor gate + subject to compatibility of 2-CT row-reduction of AND gates.
%    \item in practice, seemed to usually require 0 or 1
%    \item still has circularity problem because based on free zor
%\end{itemize}

\section{Half Gates}
Half Gates is the most recent improvement to garbled circuits.
The goal of Half Gates is to make AND gates cost two ciphertexts, while preserving properties necessary for Free XOR without adding unary gates. 

We consider the case of an AND gate $c = a \wedge b$, where the generator knows the value of $a$. 
If $a = 0$, then the generator will create a unary gate that always outpost false, $c$. 
Otherwise if $a = 1$, then the generator create a unary identity gate that always outputs $b$. 
Table \ref{tbl:halfgate-gg-garb} shows the garbled gates for different values of $a$. 

%\begin{align*}
%& \text{If $a = 0$, then } 0 \wedge b = 0 \text{, so output } H(B) \oplus C. \\
%& \text{If $a = 1$, then } 1 \wedge b = b \text{, so output } H(B \oplus \Delta) \oplus C \oplus a\Delta .
%\end{align*}
\begin{table}[h]
    \label{tbl:halfgate-gg-garb}
    \centering
    \begin{tabular}{|c|}
        \hline
        Garbled Table for $a = 0$ \\
        \hline
        $H(B) \oplus C$ \\
        $H(B) \oplus C$ \\
        \hline
    \end{tabular}
    \begin{tabular}{|c|}
        \hline
        Garbled Table for $a = 1$ \\
        \hline
        $H(B) \oplus C$ \\
        $H(B) \oplus C \oplus \Delta$ \\
        \hline
    \end{tabular} $\;\rightarrow$
    \begin{tabular}{|c|}
        \hline
        Garbled Table for any $a$ \\
        \hline
        $H(B) \oplus C$ \\
        $H(B) \oplus C \oplus a\Delta$ \\
        \hline
    \end{tabular}
    \caption{Generator's Garbled Half Gate for $a = 0$, $a = 1$, and written more succinctly with $a\Delta$ for $a \in \{0,1\}$. If $a = 0$, then $a\Delta = 0$.  Otherwise if $a = 1$, then $a\Delta = \Delta$.}
\end{table}

Since the evaluator has the wire label corresponding to b (either $B$ or $B \oplus \Delta$), the evaluator can compute the label of the output wire of the AND gate by xoring the rows in the garbled table by $H(B)$ or $H(B \oplus \Delta)$ to get $C$ or $C \oplus \Delta$ respectively. 

A further improvement can be garnered by using the garbled row-reduction trick.
We choose $C$ such that the first of the top row of the garbled table is the all zeros ciphertext. 
The top row may not necessarily be $H(B) \oplus C$, since for security the rows are permuted. 
Because the top row is all 0s, it does not need to be sent to the evaluator. 
If the evaluator should decrypt the cipher text on the top row (as directed by point and permute), then the evaluator assumes the cipher text to be all 0s. Overall, computing $a \wedge b = c$ requires two having operations by the generator, a single hash operation by the evaluator, and the communication of one ciphertext. 

We now consider computing $a \wedge b = c$, where the evaluator somehow already knows the value of $a$.
If $a = 0$, then the evaluator should acquire $C$. 
Otherwise if $a = 1$, then the evaluator should acquire $C \oplus b\Delta$, in which case it is sufficient for the evaluator to obtain $\Omega = C \oplus B$ (then xor $\Omega$ with the wire label corresponding to $b$).
Table \ref{tbl:halfgate-gg-eval} shows cipher texts which the garbler gives to the evaluator.

This table is different from other garbled tables. 
First, the table does not need to be permuted. 
Secondly, evaluation is different.
If $a = 0$, then the evaluator uses wire label $A$ to decrypt the top row of the table and acquire $C$. 
If $a = 1$, then the evaluator uses $A \oplus \Delta$ to decrypt the second row, yielding $C \oplus B$.
The evaluator then xors wire label $B + b\Delta$ by $C \oplus B$ to obtain $C \oplus b\Delta$. 
As before, the ciphertext  on the top row does not need to be communicatd by using the garbled row-reduction trick.
The generator sets $C$ such that $H(A) \oplus C = 0$ (i.e. $C = H(A)$). 
The total cost of this half gate is the same as before: two hashes by the generator, one hash by the evaluator, and once cipher text. 

\begin{table}[h]
    \label{tbl:halfgate-gg-eval}
    \centering
    \begin{tabular}{|c|}
        \hline
        Garbled Table for any $A$ \\
        \hline
        $H(A) \oplus C$ \\
        $H(A \oplus \Delta) \oplus C \oplus B$ \\
        \hline
    \end{tabular}
    \caption{Evaluator's half gate garbled table.}
\end{table}

We now put the two half gates together to form an AND gate. 
Consider the following where $r$ is a random bit generated by the generator:
\begin{equation}
    a \wedge b = a \wedge (r \oplus r \oplus b) = (a \wedge r) \oplus (a \wedge (r \oplus b)).
\end{equation}
The first AND gate, $a \wedge r$, can be computed with a generator-half-gate - the generator ``knows'' $r$. 
Furthermore, if we can let the evaluator know the value of $r \oplus b$, then the second AND gate, $(a \wedge (r \oplus b)$, can be computed with an evaluator-half-gate - the evaluator ``knows'' $r \oplus b$. 
And the final XOR can be computed with free xor at the cost of no ciphertexts. 

It is secure for the garbler to give $r \oplus b$ to the evaluator, since $r$ is random and blinds the value of $b$. 
The value of $r \oplus b$, while only a single bit, can be communicated to the evaluator for free: use the select bit (from the point and permute technique) of the false wire label on wire $b$ (so $r$ is the select bit on the true wire label of wire $b$).

The overall cost of using Half Gates for AND gates is four calls to $H$ for the generator, two calls to $H$ for the evaluator, and the communication of $2$ ciphertexts. 
Half Gates guarantees only two ciphertexts are needed per AND gate, but the tradeoff is the additional computation for both parties (i.e. computing $H$).
With FleXOR, the number of ciphertexts that need to be communicated may vary, but there is less computation required.

When secure computation becomes used in real operations, the circuit will likely not be optimized for XOR gates (reducing the number of AND gates). 
In this case, where an arbitrary function is being computed, it is hypothesized that Half Gates will outperform FleXOR. 
But in many of the cases being examined now - most notably computing AES - the circuit has been optimized heavily to have very few AND gates, hence the benefits of Half Gates are less noticeable.\footnote{At present, the AES circuit is 80\% XOR gates} 

\section{Improving Oblivious Transfer}
\al{Fix this up}
Oblivious transfer has been improved in two relevant ways for 2PC protocols. 
These improvements are called OT-extension and OT-preprocessing. 
In OT-extension a constant number of OT's can be run to generate a polynomial number of exchanged values.
In OT-preprocessing the OT's occur before the actual protocol, during what is called the offline phase, and then when the OT's needed during the online phase, simpler and efficient communication realizes the exchanged values.
This is useful because the OT step requires a large amount of communication to be sent between the sender and receiver, often resulting in OT being the bottleneck of 2PC protocols.


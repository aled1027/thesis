\chapter{Improving MPC}
A number of improvements have been made to garbled circuits over the last two decades.
The aim of this chapter is to outline the major improvements made to garbled circuits and discuss the costs and benfits of the improvments.

We consider 3 metrics that describe the costs of garbled circuits.
First, we consider bandwidth per gate.
In the classic scheme of garbled circuits, described in chapter 2, the garbler and evaluator communicated 2 pieces of information: wire labels for input wires and the fourth column of the garbled table for each gate \footnote{In chapter 2, Alice was the garbler and Bob was the evaluator. For clarify in chapter 3 and beyond, we use the term garbler to allude to the person who garbles the circuit, and we use the term evaluator to describe the person who evaluates, or decrypts, the garbled circuit.}.
Sending the input lables is an unavoid able costs, with the major caveat that using oblivious transfer to communicate the evaluator's input labels has substantial costs.
Oblivious transfer has been improved to require a small, constant amount of communication and minimal computation requirements for garbler and evaluator, if they can perform some computation \textit{before} executing the protocol.
Improvements to oblivious transfer are discussed in more detail below.

The garbler and evaluator also commnicate the garbled table\footnote{In this chapter, the garbled table will be used interchangeably with the fourth column of the garbled table.}.
Classical garbled circuits require that all four rows of the garbled table be communicated, that is 4 ciphertexts.
Recent research has reduce the number of ciphertexts to approximately $0.5$ depending on the circuit being computed.
We generally consider bandwidth to be the most important factor, as the high latency of the internet is generally the bottleneck of executing garbled circuits.

Second, we consider evaluator-side computation, which is determine by the number decryptions the evaluator performs per gate.
Third, consider garbler-side computation.
Many improvements to MPC increase the amount of garbler-side computation; having the garbler do more work can reduce the size of the garbled table which reduces bandwidth.

As we walk through the improvements to Yao's garbled circuit, we are going to think about the improvements affect the three metrics described above.
It should also be noted before we begin that these are improvements to the the computation of a single gate.
Speedups to the computation of a gate propagate through the computation of the entire garbled circuit.
For example, the computation of AES now requires approximatley $40,000$ gates, so reducing the number of ciphertexts being transmitted by $1$ per gate reduces the total ciphertexts communicated by $10,000$.

Table \ref{tbl:gc-costs} is an overview of the cost of all improvements made to garble circuits.
The table is split into three sections: size, eval cost and garble cost.
Size is the size of the garbled table per gate.
Eval cost is number of encryptions that the evaluator performs per gate, and decryptions is the number of decryptions that the garbler performs per gate.
Each section is divided into two columns: AND and XOR.
The AND columns show the requirements for AND gates, and the XOR columns show the cost for XOR gates.
The columns are separate, because many of the improvements reduce the costs of one type of gate but not the other.

The goal of this chapter is primarily to explain each row in this table.
How the improvement works, and the computational and bandwidth effects of the improvement.
We start with the earliest improvement and move chronological to the most recent improvement.

\begin{table}[t]
    \label{tbl:gc-costs}
    \centering
    \renewcommand{\arraystretch}{1.2}
    \begin{adjustbox}{width=1\textwidth}
        \begin{tabular}{|p{5cm}|c|c|c|c|c|c|c|}
            \hline
            \multirow{2}{5cm}{\centering \textbf{Garbled Circuit Improvement}} & 
            \multicolumn{2}{c|}{\textbf{Size (x$\lambda$)}} & 
            \multicolumn{2}{c|}{\textbf{Eval Cost}} & 
            \multicolumn{2}{c|}{\textbf{Garble Cost}} &
            \multirow{2}{3cm}{\centering \textbf{Assumption}} \\
            \cline{2-7}
            & \textbf{XOR} & \textbf{AND} & \textbf{XOR} & \textbf{AND}  & \textbf{XOR} & \textbf{AND} & \\
            \hline
            Classical & 4 & 4 & 1024 & $\mu$ s & a & b & a\\ \hline
            Point and Permute & TBD & TBD & TBD & $\mu$ s & a & b & a\\ \hline
            GRR3 & TBD & TBD & TBD & $\mu$ s  & a & b& a\\ \hline
            Free XOR & TBD & TBD & TBD & $\mu$ & a & bs& a  \\ \hline
            GRR2 XOR & TBD & TBD & TBD & $\mu$ & a & bs  & a\\ \hline
            FleXOR& TBD & TBD & TBD & $\mu$ & a & bs & a \\ \hline
            Half Gates & 2 & 0 & 2 & 0 & 4 & 0 & a \\ \hline
        \end{tabular}
    \end{adjustbox}
    \caption{Summary of Garbled Circuit Improvements. GRR3 stands for garbled row reduction 3 and GRR2 stands for garbled row reduction 2}
\end{table}

\section{Point and Permute}
\al{add in that rows need to be permuted!}

Beaver, Micali and Rogaway contributed the first major improvement to garbled circuits in 1990.
Recall that the garbled table is randomly permuted - that is, the rows of the garbled table are reordered randoml by the garbler before the table is sent to the evaluator \footnote{This is required for security. See chapter 2 for more information}.
Upon receiving the circuit, the garbler attempts to decrypt each row of the garbled table until a decryption succeeds \footnote{Recall that the decryption algorithm outputs a single bit indicating whether or not the decryption was successful. For more information, see chapter 1.}.

The \textit{point and permute} technique speeds up the evaluator's computation of the garbled table by removing the need to trial decrypt the ciphertexts; instead, the garbler subtly communicates which ciphertext to decrypt.
In point and permute, the garbler randomly assigns a select bit $0$ or $1$ to each wire label of the gate's input wires, where wire lables of the same wire have opposite bits.
That is, if the zeroith wire label has select bit 1, then the first wire label has select bit 0.
The garbler permutes the garbled table based on the select bits, and sends the select bits to the evaluator.
Upon receving the garbled table, the evaluator knows exactly which ciphertext to decrypt based on the select bits of the input wires.

Tables \ref{tbl:point-and-permute} show an example of point and permute.
$A, B$ and $C$ are wires, where $A_0$ and $A_1$ are the zeroith and first wire label of wire $A$ respectively.
The left table shows the select bits of the input wires $A$ and $B$.
The garbler gives $A_0$ select bit 0, determining that $A_1$ has select bit 1.
Likewise, the garbler gives $B_0$ select bit 1, determining that $B_1$ has select bit 0.

The garbler then permutes the garbled table based on the select bits. 
The permuted table is shown on the left in table \ref{tbl:point-and-permute}.
When evaluating this gate, the evaluator has $A_*$ and $B_*$ with select bits $a$ and $b$.
The evaluator decrypts the ciphertext in the row corresponding $a$ and $b$.

Intuitively, point and permute is secure because the select bits are independent of the truth value (also known as semantic value) of a the wire.
This allows the garbler to permute the table based on the select bits, and the garbler can send the evaluator the select bits.

Point and permute slightly increases garbler-side computation to substantially decrease evaluator-side computation.
The garbler samples $4$ additional random bits, and the evaluator performs a single decryption.
Without point and permute, the evaluator needs to decrypt $2.5$ ciphertexts on average, hence the garbler performs roughly $1.5$ fewer decryptions per gate.
The overall bandwidth is increased by $4$ bits per gate: a small constant increase. \footnote{The value is constant in the sense that it is independent of the security parameter.}

\begin{table}
    \label{tbl:point-and-permute}
    \centering
    \begin{tabular}{|c|c|}
        \hline
        Select Bit & Wire Label \\
        \hline
        0 & $A_0$ \\
        1 & $A_1$ \\
        1 & $B_0$ \\
        0 & $B_1$ \\
        \hline
    \end{tabular}
    \qquad
    \begin{tabular}{|c|c|}
        \hline
        Select Bits & Encryption \\
        \hline
        (0,0) & $\Enc_{A_0, B_1}(C_1)$ \\
        (0,1) & $\Enc_{A_0, B_0}(C_0)$ \\
        (1,0) & $\Enc_{A_1, B_1}(C_0)$ \\
        (1,1) & $\Enc_{A_1, B_0}(C_0)$ \\
        \hline
    \end{tabular}
    %\qquad
    %\begin{tabular}{|c|}
    %    \hline
    %    $C_0 \gets \{0,1\}^n$ \\
    %    $C_1 \gets \{0,1\}^n$ \\
    %    \hline
    %\end{tabular}
    \caption{Garbled Gate for Point and Permute}
    %\caption{Example garbled gate using point and permute. The gate being computed is given in figure \textbf{Make it 23:30 in mike's talk}}
\end{table}

\section{Garbled Row Reduction 3}
Garbled Row Reduction 3 (GRR3) reduces the size of the garbled table from 4 ciphertexts to three 3 ciphertexts.
In classical garbled circuits, the garbler 


In GRR3, the garbler uses the point and permute method.
After the garbler finds select bits and permutes the garbled table, they the ciphertext in the top row of the garbled table equal to a value that decrypts to $0^n$.
\footnote{In previous constructions the value for the ciphertext was chosen randomly.}
Upon evaluating the garbled gate, if the evaluator sees that the select bits of the input wires indicate to decrypt the first row, the evaluator simply assumes the ciphertext be of value $O^n$. 

\begin{table}[h]
    \centering
    \begin{tabular}{|c|c|}
        \hline
        Select Bit & Wire Label \\
        \hline
        0 & $A_0$ \\
        1 & $A_1$ \\
        1 & $B_0$ \\
        0 & $B_1$ \\
        \hline
    \end{tabular}
    \qquad
    \begin{tabular}{|c|c|}
        \hline
        Select Bits & Encryption \\
        \hline
        (0,1) & $\Enc_{A_0, B_0}(C_0)$ \\
        (1,0) & $\Enc_{A_1, B_1}(C_0)$ \\
        (1,1) & $\Enc_{A_1, B_0}(C_0)$ \\
        \hline
    \end{tabular}
    \qquad
    \begin{tabular}{|c|}
        \hline
        $C_0 \gets \{0,1\}^n$ \\
        $C_1 \gets \Enc_{A_0, B_1}^{-1}(0^n)$ \\
        \hline
    \end{tabular}
    \caption{Example garbled gate using point and permute and garbled row reduction 3. The gate being computed is given in figure \textbf{Make it 23:30 in mike's talk}}
\end{table}

Discuss security.

GRR3 does not have a significant effect on garbler side compuation.
The difference being that for constructing some wire lables, the garbler may need to compute $\Enc^{-1}$ instead of generating random bits. 
The evaluator needs to perform slightly less computation: in the event that the first row needs to be decrypted, the evaluator doesn't need to perform the decryption algorithm. 
This events occur with probabilty $\frac{1}{4}$, so we can extrapolate that the evaluator needs to perform $\frac{1}{4}$ fewer decryptions than wwould be necessary if only PP were being used.
GRR3 reduces the size of the garbled table from $4$ ciphertexts to $3$ ciphertexts, a $25\%$ reduction.

\section{Free XOR}
The Free XOR technique was developed by \textbf{who} in \textbf{when}.
The technique, as the name suggests, makes the computation of XOR gates essentially free.
Say the garbler is determining the lables for wire $A$.
The label associated with truth value $0$, $A_0$, is randomly sampled from $\{0,1\}^n$. 
Then the label assocated with the truth value is set such that $A_1 \gets A_0 \oplus \Delta$, where $\Delta$ is global, randomly sampled value from $\{0,1\}^n$.
If the garbler is garbling an XOR gate, then they set $C_0$ to $A \oplus B$, and like wire $A$, the garbler sets $C_1 = C_0 \oplus \Delta$.
With these wire labels, it turns out that the garbler doesn't need to send a garbled table: the evaluator can compute $C_0$ and $C_1$ by XORing the inputted wire labels.
The math for this operation is shown below:
\begin{align*}
    A \oplus B & = C \\
    (A \oplus \Delta) \oplus B & = (A \oplus B) \oplus \Delta = C \oplus \Delta \\
    A \oplus (B \oplus \Delta) & = (A \oplus B) \oplus \Delta = C \oplus \Delta \\
    (A \oplus \Delta) \oplus (B \oplus \Delta) & = (A \oplus B) \oplus (\Delta \oplus  \Delta) = C 
\end{align*}

\begin{table}[h]
    \centering
    \begin{tabular}{|c|c|}
        \hline
        Wire Label & Value\\
        \hline
        $A_0$ & $A$ \\
        $A_1$ & $A \oplus \Delta$ \\
        $B_0$ & $B$ \\
        $B_1$ & $B \oplus \Delta$ \\
        $C_0$ & $A \oplus B$ \\
        $C_1$ & $C_0 \oplus \Delta$ \\
        \hline
    \end{tabular}
    \qquad
    \begin{tabular}{|c|}
        \hline
        \hline
    \end{tabular}
    \caption{Example XOR garbled gate wires using PP, GRR3 and Free XOR.}
\end{table}

The Free XOR technique is also compatible with GRR3, but since XOR doesn't require a garbled table, GRR3 is only used on AND gates.

Using the Free XOR technique, the size of the garbled table is zero for all XOR gates and of size $3$ for AND gates.
This fact incentivizes the construction of circuits that optimize the number of XOR gates, minimize the number AND gates (while minimizing the size of the entire circuit of course).
One interesting implication of using the Free XOR technique is that an added assumption must be made to our encryption algorithm.
Since $\Delta$ is part of the key and part of the the payload\footnote{The payload is the value that is being encrypted} of the encryption algorithm, the encryption algorithm must be secure under the circularity assumption.
Fortunately, modern encryption uses AES-128, which is presumed to be secure under the circularity assumption.

%\begin{itemize}
%    \item post Fairplay
%    \item KolesnikovSchneider
%    \item $A,A \oplus \Delta$.
%    \item Note same delta every gate
%    \item Choose $C = A \oplus B$
%    \item XOR is then free: walk through that computatoin
%    \item Still works with GRR3
%    \item Because $\Delta$ is in the key and in the payload, requires circularity assumption
%    \item Incentivizes gates with as many xors as possible (has been done with AES -- why it's so fast)
%    \item Evaluator must konw what type of gate is being exectued: we have been assuming all along that the evaluator and garbler know the function.
%\end{itemize}

\section{Garbled Row Reduction 2}
Garbled row reduction 2 (GRR2) reduces the size of the garbled table for AND gates to $2$ ciphertexts, but it is not compatible with Free XOR, so XOR gates also require two ciphertexts.
The approach of GRR2 is quite different from GRR2. 
At a high level, it creates two third degree polynomials, one based on the input wires which should output $C_0$, and a second polynomial which should output $C_1$.
Since the polynomials are of three degrees, they are each uniquely generated by $3$ points. 
To construct the polynomials, the garbler uses $x,y,z$ for the first polynomail and $u,v,w$ for the second polynomial.
The garbler sends $x,y,u,v$ to the evaluator, who can interpolate the polynomial and plug in values $a,b,c$.

GRR2 is incompatible with Free XOR because the ciphertext values cannot be set to the xor of the inputer wires (e.g. $C \gets A \oplus B$), since the value of $C$ is always determined by the polynomial.

\textbf{Add to this, but no need to spend too much time on it since it's not used}

%\begin{itemize}
%    \item use unique deg-2 polynomial
%    \item use 2 second degree polynomials
%    \item then interpolate
%    \item can't do free xor.
%    \item because we have lost control of $C_0$ and $C_1$ (they are dependent on the polynomial)
%\end{itemize}

\section{FleXOR}
Before the creation of FlexXOR, MPC was at an awkward point where some circuits with a large amount of xors could be computed faster with Free XOR and circuits with fewer XORS could be computed faster with GRR2.
FleXOR serves as a method to reconcile GRR2 with Free XOR, solving the problem where the ciphertext values of AND gates are independent of $\Delta$.

FleXOR's construction is straightforward: use GRR2 on AND gates, and use Free XOR on XOR gates, correcting the delta value where necessary.
To correct the delta value, FleXOR adds in a unary gate that maps $A, A \oplus \Delta_1 \to A', A' \oplus \Delta_2$.

Suppose we have the following situation: we computing an XOR gate with input wires $A,B$ and output wire $C$.
Input wires $A$ and $B$ have each come from a different AND gate, so their labels are the result of the polynomial interpolation of GRR2.
To perform Free XOR, $A,B$ and $C$ need to be using the same delta value. 
The garbler adds an extra gate between $A$ and $B$ and the $XOR$ gate that adjusts their XOR value to the correct value.
The unary\footnote{Unary means has one input and one output.} gate maps $A,A \oplus \Delta_1 \to A', A' \oplus \Delta_2$, where $\Delta_2$ is the correct delta value for the XOR gate.

A garbled AND table costs $2$ ciphertexts, and a garbled XOR table costs $0,1$ or $2$ ciphertexts depending on how many ciphertexts need to be corrected.
This turns the creation of the circuit into a combinatorial optimization problem, where the offset of each wire needs to be determined to minimize the total cost of each XOR gate and be subject to the compatibility of GRR2 for AND gates.
Without doing too much (if any) optimization of the circuit, FleXOR usually requires $0$ or $1$ ciphertext in practice.

%\begin{itemize}
%    \item switch delta value: $A,A \oplus \Delta_1 \to A', A' \oplus \Delta_2$
%    \item cost a single ciphertext (after using GRR3 trick)
%    \item total cost 0,1,2 dependent on how many distinct deltas
%    \item make wire label outputs of AND gates based on polynomial interpolation (GRR2)
%    \item So we can do both free xor (which cost 0 CTs) and GRR2 (which cost 2 CTs per And gate + delta correction)
%    \item turns into combinatorial optimization problem: determine offset for each wire to minimize total cost of each xor gate + subject to compatibility of 2-CT row-reduction of AND gates.
%    \item in practice, seemed to usually require 0 or 1
%    \item still has circularity problem because based on free zor
%\end{itemize}

\section{Half Gates}
Half Gates is the most recent improvement Yao's garbled circuit.
The goal of Half Gates is to make AND gates cost two ciphertexts, while preserving properties necessary for Free XOR. 
I'm going to introduce Half Gates in a different way from the original paper.

We consider the case of an AND gate $c = a \wedge b$, where the generator knows the value of $a$. 
If $a = 0$, then the generator will create a unary gate that always outpost false, $c$. 
Otherwise if $a = 1$, then the generator create a unary identity gate that always outputs $b$. 
Table \ref{tbl:halfgate-gg-garb} shows the garbled gates for different values of $a$. 

%\begin{align*}
%& \text{If $a = 0$, then } 0 \wedge b = 0 \text{, so output } H(B) \oplus C. \\
%& \text{If $a = 1$, then } 1 \wedge b = b \text{, so output } H(B \oplus \Delta) \oplus C \oplus a\Delta .
%\end{align*}
\begin{table}[h]
    \label{tbl:halfgate-gg-garb}
    \centering
    \begin{tabular}{|c|}
        \hline
        Garbled Table for $a = 0$ \\
        \hline
        $H(B) \oplus C$ \\
        $H(B) \oplus C$ \\
        \hline
    \end{tabular}
    \begin{tabular}{|c|}
        \hline
        Garbled Table for $a = 1$ \\
        \hline
        $H(B) \oplus C$ \\
        $H(B) \oplus C \oplus \Delta$ \\
        \hline
    \end{tabular} $\;\rightarrow$
    \begin{tabular}{|c|}
        \hline
        Garbled Table for any $a$ \\
        \hline
        $H(B) \oplus C$ \\
        $H(B) \oplus C \oplus a\Delta$ \\
        \hline
    \end{tabular}
    \caption{Generator's Garbled Half Gate for $a = 0$, $a = 1$, and written more succinctly with $a\Delta$ for $a \in \{0,1\}$. If $a = 0$, then $a\Delta = 0$.  Otherwise if $a = 1$, then $a\Delta = \Delta$.}
\end{table}

Since the evaluator has the wire label corresponding to b (either $B$ or $B \oplus \Delta$), the evaluator can compute the label of the output wire of the AND gate by xoring the rows in the garbled table by $H(B)$ or $H(B \oplus \Delta)$ to get $C$ or $C \oplus \Delta$ respectively. 

A further improvement can be garnered by using the garbled row-reduction trick.
We choose $C$ such that the first of the top row of the garbled table is the all zeros ciphertext. 
The top row may not necessarily be $H(B) \oplus C$, since for security the rows are permuted. 
Because the top row is all 0s, it does not need to be sent to the evaluator. 
If the evaluator should decrypt the cipher text on the top row (as directed by point and permute), then the evaluator assumes the cipher text to be all 0s. Overall, computing $a \wedge b = c$ requires two having operations by the generator, a single hash operation by the evaluator, and the communication of one ciphertext. 

We now consider computing $a \wedge b = c$, where the evaluator somehow already knows the value of $a$.
If $a = 0$, then the evaluator should acquire $C$. 
Otherwise if $a = 1$, then the evaluator should acquire $C \oplus b\Delta$, in which case it is sufficient for the evaluator to obtain $\Omega = C \oplus B$ (then xor $\Omega$ with the wire label corresponding to $b$).
Table \ref{tbl:halfgate-gg-eval} shows cipher texts which the garbler gives to the evaluator.

This table is different from other garbled tables. 
First, the table does not need to be permuted. 
Secondly, evaluation is different.
If $a = 0$, then the evaluator uses wire label $A$ to decrypt the top row of the table and acquire $C$. 
If $a = 1$, then the evaluator uses $A \oplus \Delta$ to decrypt the second row, yielding $C \oplus B$.
The evaluator then xors wire label $B + b\Delta$ by $C \oplus B$ to obtain $C \oplus b\Delta$. 
As before, the ciphertext  on the top row does not need to be communicatd by using the garbled row-reduction trick.
The generator sets $C$ such that $H(A) \oplus C = 0$ (i.e. $C = H(A)$). 
The total cost of this half gate is the same as before: two hashes by the generator, one hash by the evaluator, and once cipher text. 

\begin{table}[h]
    \label{tbl:halfgate-gg-eval}
    \centering
    \begin{tabular}{|c|}
        \hline
        Garbled Table for any $A$ \\
        \hline
        $H(A) \oplus C$ \\
        $H(A \oplus \Delta) \oplus C \oplus B$ \\
        \hline
    \end{tabular}
    \caption{Evaluator's half gate garbled table.}
\end{table}

We now put the two half gates together to form an AND gate. 
Consider the following where $r$ is a random bit generated by the generator:
\begin{equation}
    a \wedge b = a \wedge (r \oplus r \oplus b) = (a \wedge r) \oplus (a \wedge (r \oplus b)).
\end{equation}
The first AND gate, $a \wedge r$, can be computed with a generator-half-gate - the generator ``knows'' $r$. 
Furthermore, if we can let the evaluator know the value of $r \oplus b$, then the second AND gate, $(a \wedge (r \oplus b)$, can be computed with an evaluator-half-gate - the evaluator ``knows'' $r \oplus b$. 
And the final XOR can be computed with free xor at the cost of no ciphertexts. 

It is secure for the garbler to give $r \oplus b$ to the evaluator, since $r$ is random and blinds the value of $b$. 
The value of $r \oplus b$, while only a single bit, can be communicated to the evaluator for free: use the select bit (from the point and permute technique) of the false wire label on wire $b$ (so $r$ is the select bit on the true wire label of wire $b$).

The overall cost of using Half Gates for AND gates is four calls to $H$ for the generator, two calls to $H$ for the evaluator, and the communication of $2$ ciphertexts. 
Half Gates guarantees only two ciphertexts are needed per AND gate, but the tradeoff is the additional computation for both parties (i.e. computing $H$).
With FleXOR, the number of ciphertexts that need to be communicated may vary, but there is less computation required.

When MPC becomes used in real operations, the circuit will likely not be optimized for XOR gates (reducing the number of AND gates). 
In this case, where an arbitrary function is being computed, it is hypothesized that Half Gates will outperform FleXOR. 
But in many of the cases being examined now - most notably computing AES - the circuit has been optimized heavily to have very few AND gates, hence the benefits of Half Gates are less noticeable.\footnote{At present, the AES circuit is 80\% XOR gates} 

    \section{Improving Oblivious Transfer}
    \al{Fix this up}
    Oblivious transfer has been improved in two relevant ways for 2PC protocols. 
    These improvements are called OT-extension and OT-preprocessing. 
    In OT-extension a constant number of OT's can be run to generate a polynomial number of exchanged values.
    In OT-preprocessing the OT's occur before the actual protocol, during what is called the offline phase, and then when the OT's needed during the online phase, simpler and efficient communication realizes the exchanged values.
    This is useful because the OT step requires a large amount of communication to be sent between the sender and receiver, often resulting in OT being the bottleneck of 2PC protocols.

